// @flow

const { logger } = require('@lagoon/commons/src/local-logging');
const { addProblem,
  deleteProblemsFromSource,
  getProblemsforProjectEnvironment,
} = require('@lagoon/commons/src/api');
const { sendToLagoonLogs } = require('@lagoon/commons/src/logs');
const { generateProblemsWebhookEventName } = require("./webhookHelpers");
const HARBOUR_VULNERABILITY_SOURCE = 'Harbor';


async function processHarborVulnerabilityList(
  webhook: WebhookRequestData,
  channelWrapperWebhooks
) {
    const { webhooktype, event, uuid, body } = webhook;

    const {
      lagoonProjectId,
      lagoonProjectName,
      lagoonEnvironmentId,
      lagoonEnvironmentName,
      lagoonServiceName,
      vulnerabilities,
    } = body;

    //Let's get the existing problems before removing them ...
    const existingProblemSet = (
      await getProblemsforProjectEnvironment(
        lagoonEnvironmentName,
        lagoonProjectId
      )
    )
      .filter((e) => e.service == lagoonServiceName)
      .reduce((prev, current) => prev.concat([current.identifier]), []);

    await deleteProblemsFromSource(
      lagoonEnvironmentId,
      HARBOUR_VULNERABILITY_SOURCE,
      lagoonServiceName
    );

    if (vulnerabilities) {
      vulnerabilities.forEach((element) => {
        addProblem({
          environment: lagoonEnvironmentId,
          identifier: element.id,
          severity: element.severity.toUpperCase(),
          source: HARBOUR_VULNERABILITY_SOURCE,
          description: element.description,
          links: element.links.pop(),
          data: JSON.stringify(element),
          version: element.version,
          fixedVersion: element.fix_version,
          service: lagoonServiceName,
          associatedPackage: element.package,
        })
          .then(() => {
            sendToLagoonLogs(
              'info',
              lagoonProjectName,
              uuid,
              generateProblemsWebhookEventName({
                source: 'harbor',
                severity: element.severity.toUpperCase(),
                isNew: !existingProblemSet.includes(element.id),
              }),
              {
                lagoonProjectId,
                lagoonProjectName,
                lagoonEnvironmentId,
                lagoonEnvironmentName,
                lagoonServiceName,
                severity: element.severity.toUpperCase(),
                vulnerability: element,
              },
              `New problem found for ${lagoonProjectName}:${lagoonEnvironmentName}:${lagoonServiceName}. Severity: ${element.severity}. Description: ${element.description}`
            );
          })
          .catch((error) =>
            sendToLagoonLogs(
              'error',
              '',
              uuid,
              `${webhooktype}:${event}:problem_insert_error`,
              { data: body },
              `Error inserting problem id ${element.id} for ${lagoonProjectId}:${lagoonEnvironmentId} -- ${error.message}`
            )
          );
      });
    }
  }

module.exports = processHarborVulnerabilityList;
